https://www.youtube.com/watch?v=nUY2WinhpcU
Transcript:
welcome back to my Commodore 64 memories videos this is where I look at old Commodore 64 software and some of the technical details behind them today we have vertical Parallax scrolling tricks so I've been thinking about LMI interrupts and vertical Parallax scrolling and I was thinking about Shadow of the Beast and how these clouds were implemented as Sprites up at the top of the screen here so you can see that there's a couple of clouds where especially this second Cloud layer here updates the expositions for the clouds and I've gone into this in a little bit more detail in one of my previous videos on Parallax scrolling but then I was also thinking about my old tari level 2C bonus level from the early 1990s I think 91 or9 to and this bonus level uses uh vertical parallx so it uses an FLD between these different layers so when tsari moves up and down the screen you can see that the different levels of the screen are expanded and contracted depending on kind of like that perspective in inverted commas and the idea is is to collect these crystals as they go scrolling across the screen so so looking at this in the c64 debug we can see that the FLD splits inside the screen use a method of uh loading the raster line comparing for the raster line being equal and when it's not equal using that previous value for the raster to then update the screen vertical scroll register in d011 what this has the effect of doing is basically telling the Vic to shift the entire uh rendered screen uh down at least one raster line and that opens up a raster line where the Vic chip will open up space between the character rows uh each of the positions for these lld splits for the vertical Parallax effect are carefully timed so that they occur at specific places on the screen so that the Vic is able to open up the spaces between the character rows without any other artifacts occurring uh this code given that it was from the early 1990s it does spend quite a lot of time uh loading the raster line comparing it with the raster line that it currently is and then looking for changes and then anding it and storing it and U DEC ing X as well so this is an un this is a this is a loop it's not unrolled or anything like that so there's extra overhead in decrementing X which is the number of lines R lines that the FLD effect the widening of the character rows effect needs to be executed for so there's some overhead there in the debug view as I move up and down we can see that there are four uh zones so four lld zones so it's just above the mountains uh just below the mountains and then below that kind of like green swirly area or above the blue band and then just underneath the blue band which is meant to be water uh there's another FLD area which opens up quite widely actually you can see the code executing at the targeting cursor for the RAS position on the debug view there that it's doing a very similar thing for all of the FLD splits loading the rasal line comparing it branching on equal um update in the value in d011 which is the screen control V register it's all doing the same thing and each of these FD splits is very very very very busy running this uh raster line synchronized code and then updating d011 then I got to thinking how I used nmis to precisely time sample updates uh within the rasine schedule to basically avoid uh problematic areas of the RAS line especially where bad lines were being drawn but also to avoid time being used for a vssp routine which enables a couple of raster lines to be used to scroll the horizont scroll the screen horizontally left and right extremely quickly without using much CPU time at all and I got to thinking that these nmi lines here that you can see highlighted that are on the left hand side of the screen each of those two line it's a line and then a an empty line where Mainline code can execute but every other line executes some non-maskable interrupt code which plays this sample which we can hear going on in the background this is real coming from a emulated but real commodor 64 so I got to thinking that I could use uh raster synchronized non-maskable interrupts along with uh an lld routine to improve the FLD routine that we just saw in tari and we can compare it with the FD routine that was used in this demo here for vertical Parallax and inverted commas now you can see as I move the spaceship up and down or whatever it is uh it opens up a couple of areas of lldd so there's a little bit of uh vertical pixel movement here in these areas up at the top of the screen and the targeting cursor uh shows the Y scroll value uh changing a little bit as it goes up and down the screen so it changes between four and five pixels not very much then we get a slightly larger area down at the bottom here which is what about 20 22 pixels something like that which does open up so there's a there's an there's an area of 22 pixels for the bottom FLD area so the code which executes in the bottom FLD area if we have a look let's move the targeting cursor down there so we can see what it's doing there we go so this code uh has some inefficiency problems so comparing it with the code from the 1990s of course it's a bit similar but it's it's doing an or with 18 which is definitely not needed you don't need to or in bits one and bit8 or One and8 um and storing it into d011 you don't really so if you notice when I scroll the targeting cursor left and right um You can see that it's actually storing the same value into d011 uh several times on the same raster line uh you definitely don't need to store the same value into d0 and one on the same raster line multiple times uh so the code is actually quite inefficient it's wasting a lot of Cycles updating the same value into the same register that it just doesn't need to um it's got few wasted noops there and that's because that it's for timing purposes and then it does a decre x and then it does comparisons with X and compar and loading X again with d012 and comparing it and this is you know quite inefficient code and all of that time where the FLD is open where the FLD is active uh this code is executing it doesn't allow any other code behind the interrupt if it's running in an interrupt which it looks like it is um it doesn't allow any other code behind the interrupt to execute it's just basically locked out the CPU onto just executing that bunch of code which is quite wasteful um for all of those raster lines so for 22 20 y 22 raster lines it's running that code continuously there are on the P 64 63 Cycles per Ras line that's you know standard that's 63 Cycles in total that uh you could execute code now the Vic chip will steal some Cycles from that if there are Sprites active and stuff like that so let's have a look at this code here um and Let's cross out this is the this is a screenshot uh describing the operation of the code that we've just seen in the c64 debugger uh let's make some notes on this shall we so yeah we need to store into d0 and one but we don't need to keep on storing the same value multiple times on a r line we don't need to load Ral line position and we don't need to deck X we don't need to and or anything we especially don't need the or of those bits before storing it back into d01 we don't need we don't need really to load any register with the contents of d012 which is the raster beam register because if we can trigger interrupts at particular Ras lines then we already know the RAS line position so we don't need to calculate values based off the raser line value by loading it from the rest line so we don't need because the raser value is already known so we can do a lot of pre-calculation for the values that go into d011 register which is the ver screen vertical scroll register and uh bit map control and stuff like that and uh the number of rows in the screen we don't need to base the values that go into that register based on the reading it from the raster beam register which is a d012 we know where we should be executing the code because we know that we should be triggering an interrupt at a precise R of beam position on the screen so we already know that so we those values are basically constant we can pre-calculate those offline outside of the interrupt and store that into the routine so we don't need to run all of this kind of like code so what can we do which is more efficient well we can take raster synchronized non-maskable interrupts which we know execute at certain positions on the screen we can use a little bit of pre-calculation and we can St values into the screen vertical scroll register much more efficiently which is what this example going to do so I'm just assembling up this this is some of the code now I'm going to be putting a link to my source code repository of course as I always do uh in the video description below so you can see this code and you can play around with it and hack around with it but basically instead of executing stores into d011 multiple times on a Ras line we can in theory and in practice actually just do an FLD store into D d011 once every four raster lines or maybe even every five raster lines we don't need to do it continuously on every single raster line because we can shift the screen down by more than one pixel position we can shift the screen down by four or five or six pixels without too much of a problem so we'll just go back to that screenshot there and we'll get rid of the air quotes because actually it is a poorly implemented fldd effect there's no air quotes needed because we've identified all of these Superfluous and inefficient instructions and we know that it doesn't take just 21 Cycles to perform the actual FLD um we know that it takes 63 cycles per Ras line and we know that there are roughly what 20 22 raster lines being used for an FLD so we can calculate the time so it's not 21 Cycles right it's actually we need to do a little bit of calculation get the calculator out 20 lines times 63 Cycles is 1,2 260 Cycles so the code was spending 1,260 Cycles to perform an FLD not 16 or not 21 or whatever so if I run the example code now uh we can see here in the c64 deui that when I move tari up and down the screen this is where the effect uh becomes quite more apparent you can see that there are three areas is where an FLD moves the screen up and down uh there's an FLD above the mountains there's an FD Above The Parallax scrolling middle area and then there's an FLD above the green plant tentacle

things and there are a bunch of Sprites whizzing all over uh these FLD splits and of course uh harking back to shadow the Beast I've imported a couple of those um Cloud Sprites to add extra layers of horizontal Parallax to the cloud layer all the way up at the top the red border color indicates uh used Mainline execution time and black indicates execution time which is free or available so the bottom FL D actually moves up and down by 32 pixels uh the middle one moves up and down by 16 and then the top one moves up and down by eight giving much more than 20 or 22 pixels of movement right even the bottom FLD when it's at its maximum extent is much more than the FLD effect which was used on on previous inefficient example so you can see here that the large FLD at the bottom moves all of those bad lines out of the way quite efficiently but if we have a look at what the code is actually doing that's probably the more important thing about this um sparse nmi based FLD effect so you might have just recalled that I mentioned that we can in theory and in practice execute lld code on every fourth or fifth Ral line we don't have to do it every

rest line right and we can use precisely timed nmis like this example here for the sample playing right but instead of having the nmi trigger at the beginning of the RAS line we can have the nmi reliably trigger in the right hand border area so that's where the targeting cursor is now the nmi because the nmi is based on timers and the timers are synchronized with the 63 cycles per Ras line we can tell the nmi to trigger every n count of the full 63 cycle rasine schedule so we can use two timers one timer counts the Cycles in a r line the other timer counts whole iterations of the first timer of the rine timer so if I move the targeting cursor up and down the screen we can see here every four raster lines it does one store into d011 yes there's a push accumulator and a load immediate value and then storing it into d011 and then setting up the timer for or the counter rather for the next four raster lines but this code which just basically triggers an nmi every four uh Ras lines where we want to do an FLD effect right it's a lot more efficient because the code once the interrupt finishes once the non-maskable interrupt completes code behind the interrupts can continue to execute so all of the code in the main line can continue to execute so you'll see here as I move the targeting cursor around once the non-maskable interrupt finishes and here we go it's finishing it's going to finish after I move the targeting cursor to the right you'll see where the the interrupt finishes but here we're inside the interrupt right and let's move the targe in cursor to the right and you can see it is executing the rest of the non-maskable interrupted RTI returns from interrupt and then it goes back into the mainline routine which is actually scrolling some data within the uh character screen there it's it's probably scrolling the green tentacle planty things down at the bottom of the screen above the bricks basically and then the next raster line which is again triggered on an nmi non-maskable interrupt then changes the uh multicolor and Screen colors so that we have again without using the raster irq method we're using a raster based enmi method by having precisely timed rights during the Border area of the screen so we can precisely time the rights into the screen the multicolor registers the horizontal scroll and the vertical scroll by using a non-maskable interrupt instead which is more efficient than using a raster irq because a raster irq triggers at the beginning of the line and then if you want to time your register updates for changing the multicolors for changing the screen color or the scroll registers you have to do some cycle weights uh to get to the correct point in the rasine schedule before you can then change those registers so by having this non-maskable interrupt Tim to start in the right hand border we get a lot more efficiency so what does the efficiency look like recall that the previous example was 1,260 Cycles but that's compared to the sparse FLD cycling Cycles so we have 22 nmis at roughly 33 cycles each um across 56 pixels of vertical movement so we have 726 Cycles giving 56 pixels of movement or um 12.9 cycles per pixel uh compared to the 1,260 Cycles used for a much smaller 22 pixels which means that it takes 57 Cycles roughly per pixel 57 being a larger number means that it is much less efficient is inefficient code compared to myspass uh FLD nmi based interrupt method so if we look at The Spar nmi FLD demo in ICU 64 we can see actually that the graphics Mac Tex text screen debug view shows that it's only used using one screen buffer there's no double buffered screen buffer needed uh because we can do all of these Scrolls by chasing the rest beam down the screen we can CH chase the rest of beam down the screen because the FLD effect doesn't waste a lot of time it's all free time basically between the non-maskable interrupts that we can use for scrolling the screen there's actually not that much code as well we can see in the memory view up at the top there that there's a whole bunch of code executing in the first bank and then there's the music routine executing further on uh down the screen but most of the memory is actually empty and free and not being accessed uh there's a little bit of oh yeah that's right it's the old two sari score panel um up in the debug Graphics map view there which isn't being used because I opened up the entire screen to have this multiple levels of horizontal Parallax plus vertical par Parx as well you can see uh The Parallax effect for this middle section here has three levels of horizontal scrolling powerlax which use the counter rotating uh dynamically updated uh Sprite uh Sprite character Graphics uh so we have the purple effect the purple effect um scrolling at a different rate or counter scrolling at a different rate to the blue paral scrolling effect there for the horizontal scrolling effect I just remembered that I mentioned that we don't need to actually enable the screen or the 25 rows bits in the screen vertical scroll register and that's because once the screen is turned on at the beginning of a frame the Commodore 64 will render a full screen regardless of what the screen on or off control bit says so if I disable the code to or in that screen enable flag and then we run the demo again it just runs as before um I just enabled the screen bit so that the c64 debug [ __ ] would render the screen uh in its uh Vic debug uh targeting cursor view that we saw earlier on if I don't include the screen enable bit then c64 debug renders an empty screen a blank screen but yeah you can see as I move up and down the the routine works just as well and actually by removing that ore with the 25 rows enable flag and also the screen on enable flag it removes what is it 22 um uh immediate auras so it saves a whole 44 bites so yes if you like these kind of technical deep di videos then please do consider liking or subscribing to this Channel or sending me a super thanks they are all always very much appreciated take care have a great day evening or night Wherever You Are
