; C64Ultimate open side border code, that doesn't use any IRQ/NMI/timer. Instead it jusy busy waits with suitable delays.
; This demonstrates just the CPU is plenty fast enough for the "cycle accurate VIC timing" needed for open side borders.
; Execute at 64MHz without badlines.
; ..\c64\acme.exe -v9 -f cbm -o c:\temp\t.prg C64UltimateSimpleOpenSideBorders.a && ..\c64\bin\LZMPi.exe -pp $37 -c64mbu c:\temp\t.prg c:\temp\t.prg $400 && curl --request POST --data-binary "@C:\temp\t.prg" http://c64u/v1/runners:run_prg

* = $400
	sei
	clc
	; Setup sprites to be visible
	lda #%11111111
	sta $d015
	; Sprites Y pos
	lda #100
!for .i , 4 {
	sta $d001 + (.i-1)*2
	sta $d009 + (.i-1)*2
	adc #21
}
	lda #0
	ldx #1
!for .i , 4 {
	sta $d027 + (.i-1) * 2
	stx $d028 + (.i-1) * 2
}
	
	lda #0
!for .i , 4 {
	sta $d000 + (.i-1)*2
	adc #8
}
	lda #72
!for .i , 4 {
	sta $d008 + (.i-1)*2
	adc #8
}
	lda #%11110000
	sta $d010
	
	; Open side borders, with screen colour change to show the position
.l1
	ldy #80
.l2
	jsr WaitRaster
	; Even though "bad lines" are turned off, there seems to be 40 cycles at 64 MHz used for the line fetch.
	; At least it's not 40 cycles at 1MHz, which would be much longer in terms of time.
	tya
	and #%111
	cmp #3
	beq .isBadLine
	; Just waste some time to make the normal lines match with the bad lines timing
	ldx #5
	jsr Delay1
.isBadLine
	
	ldx #200
	jsr Delay2
	ldx #46
	jsr Delay3
	jsr OpenSideBorder
	iny
	cpy #200
	bne .l2

	jmp .l1

	
WaitRaster
.wl1
	cpy $d012
	bne .wl1
	rts


Delay1
.delay
	dex
	bne .delay
	rts

Delay2
.delay2
!for .i , 5 {
	nop
}
	dex
	bne .delay2
	rts

Delay3
.delay3
!for .i , 2 {
	nop
}
	dex
	bne .delay3
	rts

OpenSideBorder
	dec $d021
	dec $d016
	ldx #8
	jsr Delay1
	inc $d021
	inc $d016
	rts

!for .i , 40 {
	!scr "testing... "
}

; Sprite pointers, using the code as sprite frame data
* = $7f8
	!by 16,17,18,19,20,21,22,23
